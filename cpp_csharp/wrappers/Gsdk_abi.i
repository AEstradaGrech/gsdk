%module(directors="1") interop_gsdk;
%rename("interop_%s", %$isclass) "";
%rename("interop_%s", %$isenum) "";

%feature("director") ShutdownCallback;
%feature("director") HealthCallback;
%feature("director") MaintenanceCallback;

%nodefaultctor GSDKInitializationException;

// We want all of our generated classes to have the default access modifier.  The default access modifier for classes
// makes them essentially "private".  This means that they will only be visible
// to other classes in the same package.  The intent in the Java/CSharp projects is to hand write a thin layer of public classes
// that will adapt the auto-generated classes produced by SWIG.  Therefore, in the future if we decide to move away from SWIG
// for any reason, then we can simply re-implement the thin public layer in the Java/CSharp libraries and the users of those
// libraries won't notice the change.

#ifdef SWIGJAVA
%typemap(javaclassmodifiers)   SWIGTYPE, SWIGTYPE *, SWIGTYPE &, SWIGTYPE &&, SWIGTYPE [], SWIGTYPE (CLASS::*) "class"
%pragma(java) jniclassclassmodifiers="class"
%pragma(java) moduleclassmodifiers="class"
#endif

#ifdef SWIGCSHARP 
%typemap(csclassmodifiers)   SWIGTYPE, SWIGTYPE *, SWIGTYPE &, SWIGTYPE &&, SWIGTYPE [], SWIGTYPE (CLASS::*) "class"
%pragma(csharp) imclassclassmodifiers="class"
%pragma(csharp) moduleclassmodifiers="class"
#endif

%include "enums.swg"

#ifdef SWIGJAVA
%typemap(javaclassmodifiers) enum SWIGTYPE "enum"
%javaconst(1);
#endif

typedef long long time_t;

%include "std_string.i"
%include "exception.i"

%include "..\cppsdk\gsdk.h"

// If decide to use arrays instead of std::vector in our ABI, then uncomment the two lines below.
// %include "arrays_java.i"
// JAVA_ARRAYSOFCLASSES(Microsoft::Azure::Gaming::ConnectedPlayer)

using namespace Microsoft::Azure::Gaming;

%include "std_vector.i"
%include "std_map.i"

%template(interop_ConnectedPlayerVector) std::vector<ConnectedPlayer>;
%template(interop_ConfigSettingMap) std::map<std::string, std::string>;

%insert("begin") %{
// SWIG will auto-generate code that uses "strncpy".  That function will generate a compiler warning that indicates
// that we should use "strncpy_s" instead.  However, modifying the auto-generated code isn't an option.
// Therefore, the "_CRT_SECURE_NO_WARNINGS" macro is defined and the warnings are disabled.  The catch is that we don't want the 
// warnings disabled across all of the files in this project, just in the code generated by SWIG.
// That means we have to disable pre-compiled headers for the auto-generated code because this symbol
// has to be defined before we include the header that contains the deprecated functions.  If we were to 
// put the macro definition in the pre-compiled header then it would apply to all files in this project
// and that's not desirable.
#define _CRT_SECURE_NO_WARNINGS
#include "pch.h"
#include "..\cppsdk\gsdk.h"
%}

%{
#include <time.h>
using namespace Microsoft::Azure::Gaming;
%}

%inline %{
    class ShutdownCallback{
        public:
            virtual void OnShutdown() = 0;
            virtual ~ShutdownCallback() {};
    };

    class HealthCallback{
        public:
            virtual bool OnHealthCheck() = 0;
            virtual ~HealthCallback() {};
    };

    class MaintenanceCallback{
        public:
            virtual void OnMaintenanceScheduled(time_t newTimeUtc) = 0;
            virtual ~MaintenanceCallback() {};
    };

    bool readyForPlayers()
    {
        return Microsoft::Azure::Gaming::GSDK::readyForPlayers();
    }

    std::map<std::string, std::string> getConfigSettings()
    {
        // TODO: Workaround since SWIG doesn't support unordered_map yet
        auto config = Microsoft::Azure::Gaming::GSDK::getConfigSettings();
        return std::map<std::string, std::string>(config.begin(), config.end());
    }

    void start()
    {
        Microsoft::Azure::Gaming::GSDK::start();
    }

    // Considered using an array of "ConnectedPlayer" here instead of a std::vector in order to keep STL code
    // out of the ABI.  However, the default behavior from SWIG is to create a copy of all of the
    // elements in the array when it is passed from Java to C++.  Then in the C++ code we would have 
    // created yet another copy of all of the elements when we convered the array into a std::vector.
    // By including the std::vector directly in our method signature we save one copy.
    void updateConnectedPlayers( std::vector< ConnectedPlayer > currentlyConnectedPlayers )
    {
        Microsoft::Azure::Gaming::GSDK::updateConnectedPlayers(currentlyConnectedPlayers);
    }

    void registerShutdownCallback(ShutdownCallback* callback)
    {
        auto callbackFunction = [=]()
        {
            // What happens if "callback" gets de-allocated?
            callback->OnShutdown();
        };

        Microsoft::Azure::Gaming::GSDK::registerShutdownCallback(callbackFunction);
    }

    void registerHealthCallback(HealthCallback* callback)
    {
        auto callbackFunction = [=]()
        {
            // What happens if "callback" gets de-allocated?
            return callback->OnHealthCheck();
        };

        Microsoft::Azure::Gaming::GSDK::registerHealthCallback(callbackFunction);
    }

    void registerMaintenanceCallback(MaintenanceCallback* callback)
    {
        auto callbackFunction = [=](tm newTimeUtc)
        {
            time_t newTime = _mkgmtime(&newTimeUtc);
            return callback->OnMaintenanceScheduled(newTime);
        };

        Microsoft::Azure::Gaming::GSDK::registerMaintenanceCallback(callbackFunction);
    }

    void logMessage(std::string message)
    {
        Microsoft::Azure::Gaming::GSDK::logMessage(message);
    }

    const std::string &getLogsDirectory()
    {
        return Microsoft::Azure::Gaming::GSDK::getLogsDirectory();
    }
%}